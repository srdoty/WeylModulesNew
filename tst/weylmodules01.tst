# WeylModules, chapter 2
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("weylmodules01.tst");

# doc/_Chapter_Weyl_modules.xml:50-55
gap> V:= WeylModule(2,[1,0],"A",2);
V[ 1, 0 ]
gap> W:= WeylModule(V,[1,2]);
V[ 1, 2 ]

# doc/_Chapter_Weyl_modules.xml:74-79
gap> W:= WeylModule(2,[2,0],"A",2);
V[ 2, 0 ]
gap> Q:= QuotientWeylModule(SocleWeyl(W));
3-dimensional quotient of V[ 2, 0 ]

# doc/_Chapter_Weyl_modules.xml:110-123
gap> W:= WeylModule(2,[2,0],"A",2);
V[ 2, 0 ]
gap> m:= MaximalVectors(W);
[ 1*v0, y1*v0 ]
gap> S:= SubWeylModule(W, m[2]);
3-dimensional submod of V[ 2, 0 ]
gap> SubWeylModule(S, m[1]);
6-dimensional submod of V[ 2, 0 ]
gap> SubWeylModule(W, m);
6-dimensional submod of V[ 2, 0 ]
gap> SubWeylModule(S, m);
6-dimensional submod of V[ 2, 0 ]

# doc/_Chapter_Weyl_modules.xml:155-166
gap> W:= WeylModule(2,[2,0],"A",2);
V[ 2, 0 ]
gap> Q:= QuotientWeylModule(SocleWeyl(W));
3-dimensional quotient of V[ 2, 0 ]
gap> m:= MaximalVectors(Q);
[ 1*v0 ]
gap> S:= SubWeylModule(Q,m[1]);
3-dimensional submod of 3-dimensional quotient of V[ 2, 0 ]
gap> SubWeylModule(Q,m);
3-dimensional submod of 3-dimensional quotient of V[ 2, 0 ]

# doc/_Chapter_Weyl_modules.xml:246-261
gap> V:=WeylModule(V,[4,0]);
V[ 4, 0 ]
gap> Dim(V);
15
gap> m:= MaximalVectors(V);
[ 1*v0, y1*v0 ]
gap> S:= SubWeylModule(V,m[2]);
9-dimensional submod of V[ 4, 0 ]
gap> Q:= QuotientWeylModule(S);
6-dimensional quotient of V[ 4, 0 ]
gap> mm:= MaximalVectors(Q);
[ 1*v0, y1^(2)*v0 ]
gap> T:= SubWeylModule(Q, mm[2]);
3-dimensional submod of 6-dimensional quotient of V[ 4, 0 ]

# doc/_Chapter_Weyl_modules.xml:274-286
gap> BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y1^(2)*v0, y1*y3*v0, y1^(3)*v0, y3^(2)*v0, 
  y1^(2)*y3*v0, y1^(4)*v0, y1*y3^(2)*v0, y1^(3)*y3*v0, y3^(3)*v0, 
  y1^(2)*y3^(2)*v0, y1*y3^(3)*v0, y3^(4)*v0 ]
gap> BasisVecs(S);
[ y1*v0, y3*v0, y1*y3*v0, y1^(3)*v0, y1*y3^(2)*v0, y1^(2)*y3*v0, y3^(3)*v0, 
  y1^(3)*y3*v0, y1*y3^(3)*v0 ]
gap> BasisVecs(Q);
[ 1*v0, y1^(2)*v0, y3^(2)*v0, y1^(4)*v0, y1^(2)*y3^(2)*v0, y3^(4)*v0 ]
gap> BasisVecs(T);
[ y1^(2)*v0, y3^(2)*v0, y1^(2)*y3^(2)*v0 ]

# doc/_Chapter_Weyl_modules.xml:307-320
gap> Character(V);
[ [ 4, 0 ], 1, [ 2, 1 ], 1, [ 3, -1 ], 1, [ 0, 2 ], 1, [ 1, 0 ], 1, 
  [ -2, 3 ], 1, [ 2, -2 ], 1, [ -1, 1 ], 1, [ -4, 4 ], 1, [ 0, -1 ], 1, 
  [ -3, 2 ], 1, [ 1, -3 ], 1, [ -2, 0 ], 1, [ -1, -2 ], 1, [ 0, -4 ], 1 ]
gap> Character(Q);
[ [ 4, 0 ], 1, [ 0, 2 ], 1, [ 2, -2 ], 1, [ -4, 4 ], 1, [ -2, 0 ], 1, 
  [ 0, -4 ], 1 ]
gap> Character(S);
[ [ 2, 1 ], 1, [ 3, -1 ], 1, [ 1, 0 ], 1, [ -2, 3 ], 1, [ 0, -1 ], 1, 
  [ -1, 1 ], 1, [ 1, -3 ], 1, [ -3, 2 ], 1, [ -1, -2 ], 1 ]
gap> Character(T);
[ [ 0, 2 ], 1, [ 2, -2 ], 1, [ -2, 0 ], 1 ]

# doc/_Chapter_Weyl_modules.xml:341-350
gap> DecompositionNumbers(V);
[ [ 4, 0 ], 1, [ 2, 1 ], 1, [ 0, 2 ], 1 ]
gap> DecompositionNumbers(Q);
[ [ 4, 0 ], 1, [ 0, 2 ], 1 ]
gap> DecompositionNumbers(S);
[ [ 2, 1 ], 1 ]
gap> DecompositionNumbers(T);
[ [ 0, 2 ], 1 ]

# doc/_Chapter_Weyl_modules.xml:368-377
gap> Dim(V);
15
gap> Dim(Q);
6
gap> Dim(S);
9
gap> Dim(T);
3

# doc/_Chapter_Weyl_modules.xml:398-407
gap> DominantWeights(V);
[ [ 4, 0 ], [ 2, 1 ], [ 0, 2 ], [ 1, 0 ] ]
gap> DominantWeights(Q);
[ [ 4, 0 ], [ 0, 2 ] ]
gap> DominantWeights(S);
[ [ 2, 1 ], [ 1, 0 ] ]
gap> DominantWeights(T);
[ [ 0, 2 ] ]

# doc/_Chapter_Weyl_modules.xml:427-437
gap> DominantWeightSpaces(V);
[ [ 4, 0 ], [ 1*v0 ], [ 2, 1 ], [ y1*v0 ], [ 0, 2 ], [ y1^(2)*v0 ], [ 1, 0 ], 
  [ y1*y3*v0 ] ]
gap> DominantWeightSpaces(Q);
[ [ 4, 0 ], [ 1*v0 ], [ 0, 2 ], [ y1^(2)*v0 ] ]
gap> DominantWeightSpaces(S);
[ [ 2, 1 ], [ y1*v0 ], [ 1, 0 ], [ y1*y3*v0 ] ]
gap> DominantWeightSpaces(T);
[ [ 0, 2 ], [ y1^(2)*v0 ] ]

# doc/_Chapter_Weyl_modules.xml:456-468
gap> Weights(V);
[ [ 4, 0 ], [ 2, 1 ], [ 3, -1 ], [ 0, 2 ], [ 1, 0 ], [ -2, 3 ], [ 2, -2 ], 
  [ -1, 1 ], [ -4, 4 ], [ 0, -1 ], [ -3, 2 ], [ 1, -3 ], [ -2, 0 ], 
  [ -1, -2 ], [ 0, -4 ] ]
gap> Weights(Q);
[ [ 4, 0 ], [ 0, 2 ], [ 2, -2 ], [ -4, 4 ], [ -2, 0 ], [ 0, -4 ] ]
gap> Weights(S);
[ [ 2, 1 ], [ 3, -1 ], [ 1, 0 ], [ -2, 3 ], [ 0, -1 ], [ -1, 1 ], [ 1, -3 ], 
  [ -3, 2 ], [ -1, -2 ] ]
gap> Weights(T);
[ [ 0, 2 ], [ 2, -2 ], [ -2, 0 ] ]

# doc/_Chapter_Weyl_modules.xml:488-508
gap> WeightSpaces(V);
[ [ 4, 0 ], [ 1*v0 ], [ 2, 1 ], [ y1*v0 ], [ 3, -1 ], [ y3*v0 ], [ 0, 2 ], 
  [ y1^(2)*v0 ], [ 1, 0 ], [ y1*y3*v0 ], [ -2, 3 ], [ y1^(3)*v0 ], [ 2, -2 ], 
  [ y3^(2)*v0 ], [ -1, 1 ], [ y1^(2)*y3*v0 ], [ -4, 4 ], [ y1^(4)*v0 ], 
  [ 0, -1 ], [ y1*y3^(2)*v0 ], [ -3, 2 ], [ y1^(3)*y3*v0 ], [ 1, -3 ], 
  [ y3^(3)*v0 ], [ -2, 0 ], [ y1^(2)*y3^(2)*v0 ], [ -1, -2 ], 
  [ y1*y3^(3)*v0 ], [ 0, -4 ], [ y3^(4)*v0 ] ]
gap> WeightSpaces(Q);
[ [ 4, 0 ], [ 1*v0 ], [ 0, 2 ], [ y1^(2)*v0 ], [ 2, -2 ], [ y3^(2)*v0 ], 
  [ -4, 4 ], [ y1^(4)*v0 ], [ -2, 0 ], [ y1^(2)*y3^(2)*v0 ], [ 0, -4 ], 
  [ y3^(4)*v0 ] ]
gap> WeightSpaces(S);
[ [ 2, 1 ], [ y1*v0 ], [ 3, -1 ], [ y3*v0 ], [ 1, 0 ], [ y1*y3*v0 ], 
  [ -2, 3 ], [ y1^(3)*v0 ], [ 0, -1 ], [ y1*y3^(2)*v0 ], [ -1, 1 ], 
  [ y1^(2)*y3*v0 ], [ 1, -3 ], [ y3^(3)*v0 ], [ -3, 2 ], [ y1^(3)*y3*v0 ], 
  [ -1, -2 ], [ y1*y3^(3)*v0 ] ]
gap> WeightSpaces(T);
[ [ 0, 2 ], [ y1^(2)*v0 ], [ 2, -2 ], [ y3^(2)*v0 ], [ -2, 0 ], 
  [ y1^(2)*y3^(2)*v0 ] ]

# doc/_Chapter_Weyl_modules.xml:527-536
gap> WeightSpace(V, [2,1]);
[ y1*v0 ]
gap> WeightSpace(Q, [2,1]);
[  ]
gap> WeightSpace(S, [2,1]);
[ y1*v0 ]
gap> WeightSpace(T, [2,-2]);
[ y3^(2)*v0 ]

# doc/_Chapter_Weyl_modules.xml:555-564
gap> TheCharacteristic(V);
2
gap> TheCharacteristic(Q);
2
gap> TheCharacteristic(S);
2
gap> TheCharacteristic(T);
2

# doc/_Chapter_Weyl_modules.xml:583-592
gap> TheLieAlgebra(V);
<Lie algebra of dimension 8 over Rationals>
gap> TheLieAlgebra(Q);
<Lie algebra of dimension 8 over Rationals>
gap> TheLieAlgebra(S);
<Lie algebra of dimension 8 over Rationals>
gap> TheLieAlgebra(T);
<Lie algebra of dimension 8 over Rationals>

# doc/_Chapter_Weyl_modules.xml:633-654
gap> MaximalVectors(V);
[ 1*v0, y1*v0 ]
gap> m:= MaximalVectors(V);
[ 1*v0, y1*v0 ]
gap> List(m, Weight);
[ [ 4, 0 ], [ 2, 1 ] ]
gap> MaximalVectors(V, [2,1]);
[ y1*v0 ]
gap> m:= MaximalVectors(Q);
[ 1*v0, y1^(2)*v0 ]
gap> List(m, Weight);
[ [ 4, 0 ], [ 0, 2 ] ]
gap> MaximalVectors(Q, [0,2]);
[ y1^(2)*v0 ]
gap> m:= MaximalVectors(S);
[ y1*v0 ]
gap> List(m, Weight);
[ [ 2, 1 ] ]
gap> MaximalVectors(S, [2,1]);
[ y1*v0 ]

# doc/_Chapter_Weyl_modules.xml:673-678
gap> V:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> IsAmbiguous(V);
true

# doc/_Chapter_Weyl_modules.xml:697-702
gap> V:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> AmbiguousMaxVecs(V);
[ y1*y3*v0, y4*v0 ]

# doc/_Chapter_Weyl_modules.xml:736-749
gap> V:= WeylModule(2, [1,0], "G", 2);
V[ 1, 0 ]
gap> L:= TheLieAlgebra(V);
<Lie algebra of dimension 14 over Rationals>
gap>  g:= LatticeGeneratorsInUEA(L);
[ y1, y2, y3, y4, y5, y6, x1, x2, x3, x4, x5, x6, ( h13/1 ), ( h14/1 ) ]
gap> b:= BasisVecs(V);
[ 1*v0, y1*v0, y3*v0, y4*v0, y5*v0, y6*v0, y1*y6*v0 ]
gap> ActOn(V, g[1]^2 + g[7], b[1]);
0*v0
gap> ActOn(V, g[1]*g[6], b[1]);
y1*y6*v0

# doc/_Chapter_Weyl_modules.xml:766-771
gap> V:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> Generator(V);
1*v0

# doc/_Chapter_Weyl_modules.xml:790-797
gap> V:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> GensSocleLayers(V);
[ [ y1*y4*v0, y1*y3*y4*v0+y1*y6*v0+y3*y5*v0, 
      y1*y4*y6*v0+y3*y4*y5*v0+y4^(3)*v0 ], [ y4*v0, y1^(2)*y3*y6*v0 ], 
  [ y1*y3*v0 ], [ y5*y6*v0 ], [ y1*y6*v0+y4^(2)*v0 ], [ 1*v0 ] ]

# doc/_Chapter_Weyl_modules.xml:820-829
gap> PrintSocleLayers(V);
Printing highest weights of simples in socle layers of V[ 3, 0 ]
Layer 1: [ [ 0, 1 ], [ 1, 0 ], [ 0, 0 ] ]
Layer 2: [ [ 2, 0 ], [ 0, 0 ] ]
Layer 3: [ [ 2, 0 ] ]
Layer 4: [ [ 0, 0 ] ]
Layer 5: [ [ 1, 0 ] ]
Layer 6: [ [ 3, 0 ] ]

# doc/_Chapter_Weyl_modules.xml:846-853
gap> V:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> SocleSeries(V);
[ 21-dimensional submod of V[ 3, 0 ], 28-dimensional submod of V[ 3, 0 ], 
  34-dimensional submod of V[ 3, 0 ], 35-dimensional submod of V[ 3, 0 ], 
  41-dimensional submod of V[ 3, 0 ], 77-dimensional submod of V[ 3, 0 ] ]

# doc/_Chapter_Weyl_modules.xml:869-874
gap> V:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> SocleWeyl(V);
21-dimensional submod of V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:901-906
gap> V:= WeylModule(3,[3,0],"A",2);
V[ 3, 0 ]
gap> MaximalSubmodule(V);
7-dimensional submod of V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:922-927
gap> V:= WeylModule(3,[3,0],"A",2);
V[ 3, 0 ]
gap> Q:= SimpleQuotient(V);
3-dimensional quotient of V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:955-958
gap> AmbientWeylModule(Q);
V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:979-982
gap> DefiningKernel(Q);
7-dimensional submod of V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:1007-1014
gap> V:= WeylModule(3,[3,0],"A",2);
V[ 3, 0 ]
gap> S:= MaximalSubmodule(V);
7-dimensional submod of V[ 3, 0 ]
gap> AmbientWeylModule(S);
V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:1031-1034
gap> Generators(S);
[ y1*v0 ]

# doc/_Chapter_Weyl_modules.xml:1050-1059
gap> V:= WeylModule(3,[3,0],"A",2);
V[ 3, 0 ]
gap> S:= MaximalSubmodule(V);
7-dimensional submod of V[ 3, 0 ]
gap> g:= Generators(S);
[ y1*v0 ]
gap> IsWithin(S, g[1]);
true

# doc/_Chapter_Weyl_modules.xml:1077-1088
gap> W:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> g:= Generators(SocleWeyl(W)); 
[ y1*y4*v0, y1*y3*y4*v0+y1*y6*v0+y3*y5*v0, y1*y4*y6*v0+y3*y4*y5*v0+y4^(3)*v0 ]
gap> S:= SubWeylModule(W, g[1]);
14-dimensional submod of V[ 3, 0 ]
gap> T:= NextSocle(S);
21-dimensional submod of V[ 3, 0 ]
gap> DecompositionNumbers(T);
[ [ 0, 1 ], 1, [ 1, 0 ], 1, [ 0, 0 ], 1 ]

# doc/_Chapter_Weyl_modules.xml:1107-1112
gap> g:= GensNextSocle(S);
[ y1*y6*v0+y3*y5*v0, y4^(3)*v0 ]
gap> List(g, Weight);
[ [ 1, 0 ], [ 0, 0 ] ]

# doc/_Chapter_Weyl_modules.xml:1129-1152
gap> W:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> ss:= SocleSeries(W);
[ 21-dimensional submod of V[ 3, 0 ], 28-dimensional submod of V[ 3, 0 ], 
  34-dimensional submod of V[ 3, 0 ], 35-dimensional submod of V[ 3, 0 ], 
  41-dimensional submod of V[ 3, 0 ], 77-dimensional submod of V[ 3, 0 ] ]
gap> amv:= AmbiguousMaxVecs(W);
[ y1*y3*v0, y4*v0 ]
gap> Q1:= SocleLengthTwoQuotient(ss[4]);
42-dimensional quotient of V[ 3, 0 ]
gap> PrintSocleLayers(Q1);
Printing highest weights of simples in socle layers of 
42-dimensional quotient of V[ 3, 0 ]
Layer 1: [ [ 1, 0 ] ]
Layer 2: [ [ 3, 0 ] ]
gap> Q2:= SocleLengthTwoQuotient(SubWeylModule(W,amv[1]+amv[2]));
48-dimensional quotient of V[ 3, 0 ]
gap> PrintSocleLayers(Q2);
Printing highest weights of simples in socle layers of 
48-dimensional quotient of V[ 3, 0 ]
Layer 1: [ [ 2, 0 ], [ 1, 0 ] ]
Layer 2: [ [ 3, 0 ] ]

# doc/_Chapter_Weyl_modules.xml:1178-1191
gap> Q:= TwoFactorQuotientsContaining(SubWeylModule(W,amv[1]+amv[2]));
[ 42-dimensional quotient of V[ 3, 0 ], 42-dimensional quotient of V[ 3, 0 ] ]
gap> PrintSocleLayers(Q[1]);
Printing highest weights of simples in socle layers of 
42-dimensional quotient of V[ 3, 0 ]
Layer 1: [ [ 1, 0 ] ]
Layer 2: [ [ 3, 0 ] ]
gap> PrintSocleLayers(Q[2]);
Printing highest weights of simples in socle layers of 
42-dimensional quotient of V[ 3, 0 ]
Layer 1: [ [ 2, 0 ] ]
Layer 2: [ [ 3, 0 ] ]

# doc/_Chapter_Weyl_modules.xml:1221-1233
gap> W:= WeylModule(2,[3,0],"G",2);
V[ 3, 0 ]
gap> m:= AmbiguousMaxVecs(W); List(m, Weight);
[ y1*y3*v0, y4*v0 ]
[ [ 2, 0 ], [ 2, 0 ] ]
gap> Q:= QuotientWeylModule(SubWeylModule(W,m[1]));
64-dimensional quotient of V[ 3, 0 ]
gap> subQ:= SubWeylModule(Q, m[2]);
21-dimensional submod of 64-dimensional quotient of V[ 3, 0 ]
gap> AmbientQuotient(subQ);
64-dimensional quotient of V[ 3, 0 ]

# doc/_Chapter_Weyl_modules.xml:1251-1254
gap> Generators(subQ);
[ y4*v0 ]

# doc/_Chapter_Weyl_modules.xml:1274-1279
gap> IsWithin(subQ,m[2]);
true
gap> IsWithin(subQ, Generator(Q));
false

# doc/_Chapter_Weyl_modules.xml:1301-1308
gap> DecompositionNumbers(subQ);
[ [ 2, 0 ], 1, [ 0, 1 ], 1, [ 0, 0 ], 1 ]
gap> N:= NextSocle(subQ);
22-dimensional submod of 64-dimensional quotient of V[ 3, 0 ]
gap> DecompositionNumbers(N);
[ [ 2, 0 ], 1, [ 0, 1 ], 1, [ 0, 0 ], 2 ]

#
gap> STOP_TEST("weylmodules01.tst", 1);
