<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (WeylModules) - Chapter 4: Schur algebras and symmetric groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4_mj.html">[MathJax on]</a></p>
<p><a id="X7817A3B07E17884E" name="X7817A3B07E17884E"></a></p>
<div class="ChapSects"><a href="chap4.html#X7817A3B07E17884E">4 <span class="Heading">Schur algebras and symmetric groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X82C9B62E81E4B44F">4.1 <span class="Heading">Compositions and weights</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7D3C52B382720016">4.2 <span class="Heading">Bounded partitions</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X83A8D18080E546E4">4.3 <span class="Heading">Listing partitions</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X802799E57A84025C">4.4 <span class="Heading">Schur algebras</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X7BE4F15F78127B12">4.5 <span class="Heading">Symmetric groups</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4.html#X78EDAF2F86560B70">4.6 <span class="Heading">The Mullineux correspondence</span></a>
</span>
</div>
</div>

<h3>4 <span class="Heading">Schur algebras and symmetric groups</span></h3>

<p>The decomposition numbers for the algebraic group <span class="Math">SL_n</span> of type <span class="Math">A_{n−1}</span> determine the decomposition numbers for the corresponding Schur algebras, and thus also determine the decomposition numbers for symmetric groups. People working with Schur algebras and symmetric groups often prefer to use <em>partitions</em> to label highest weights. Although it is trivial to convert between <span class="Math">SL_n</span> weight notation and partition notation, for the sake of convenience, we provide a few functions that perform such conversions, and various other functions related to Schur algebras and symmetric groups.</p>

<p>It should be noted that the functions for symmetric groups are quite slow, so readers interested in symmetric group computations may want to look elsewhere for better tools.</p>

<p><a id="X82C9B62E81E4B44F" name="X82C9B62E81E4B44F"></a></p>

<h4>4.1 <span class="Heading">Compositions and weights</span></h4>

<p>A (weak) <em>composition</em> of degree <span class="Math">r</span> is a finite sequence <span class="Math">c = [c_1 , \dots , c_n ]</span> of non-negative integers which add up to <span class="Math">r</span>. The number <span class="Math">n</span> of parts of <span class="Math">c</span> is called its <em>length</em>. Note that zeros are allowed in weak compositions, which are called compositions from now on.</p>

<p>One may identify the set of compositions of length <span class="Math">n</span> with the set of polynomial weights of the algebraic group <span class="Math">GL_n</span>. Note that a composition is a partition if and only if it is a dominant weight relative to the diagonal maximal torus in <span class="Math">GL_n</span>.</p>


<pre class="normal">

CompositionToWeight( c )
WeightToComposition( r , wt )

</pre>

<p><code class="keyw">CompositionToWeight</code> converts a given list <var class="Arg">c</var> (of length <span class="Math">n</span>) into an <span class="Math">SL_n</span> weight, by taking successive differences in the parts of <var class="Arg">c</var>. This produces a list of length <span class="Math">n-1</span>. <code class="keyw">WeightToComposition</code> does the reverse operation, padding with zeros if necessary in order to return a composition of degree <span class="Math">r</span>. The degree must be specified since it is not uniquely determined by the given weight. (The degree is unique modulo <span class="Math">n</span>.) The length <span class="Math">n</span> of the output is always one more than the length of the input.</p>

<p>As a special case, these operations take partitions to dominant weights, and vice versa.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wt:= CompositionToWeight( [3,3,2,1,1,0,0] );</span>
[ 0, 1, 1, 0, 1, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightToComposition(10, wt);</span>
[ 3, 3, 2, 1, 1, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightToComposition(17, wt);</span>
[ 4, 4, 3, 2, 2, 1, 1 ]
</pre></div>

<p><a id="X7D3C52B382720016" name="X7D3C52B382720016"></a></p>

<h4>4.2 <span class="Heading">Bounded partitions</span></h4>

<p>There are two functions that compute lists of bounded partitiuons.</p>


<pre class="normal">

BoundedPartitions( n, r, s )
BoundedPartitions( n, r )

</pre>

<p>The first form returns a list of all partitions of <var class="Arg">n</var> parts in degree <var class="Arg">r</var> whose parts lie in the closed interval <span class="Math">[0,s]</span>. The second form is equivalent to the first where <span class="Math">s = r</span>; that is, it returns a list of all of <var class="Arg">n</var> parts in degree <var class="Arg">r</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundedPartitions(4,3,2);</span>
[ [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundedPartitions(4,3,3);</span>
[ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundedPartitions(4,3);</span>
[ [ 3, 0, 0, 0 ], [ 2, 1, 0, 0 ], [ 1, 1, 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundedPartitions(4,4,4);</span>
[ [ 4, 0, 0, 0 ], [ 3, 1, 0, 0 ], [ 2, 2, 0, 0 ], [ 2, 1, 1, 0 ],
[ 1, 1, 1, 1 ] ]
</pre></div>

<p>Notice that we sometimes allow zero parts in partitions.</p>

<p><a id="X83A8D18080E546E4" name="X83A8D18080E546E4"></a></p>

<h4>4.3 <span class="Heading">Listing partitions</span></h4>

<p>We can also compute a list of all partitions of a given degree.</p>


<pre class="normal">

AllPartitions( r )

</pre>

<p>This returns a list of all the partitions of <var class="Arg">r</var>, where zero parts are not allowed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllPartitions(4);</span>
[ [ 4 ], [ 3, 1 ], [ 2, 2 ], [ 2, 1, 1 ], [ 1, 1, 1, 1 ] ]
</pre></div>

<p>One can also calculate lists of <span class="Math">p</span>-restricted and <span class="Math">p</span>-regular partitions, where <span class="Math">p</span> is a given prime.</p>


<pre class="normal">

pRestrictedPartitions( p, n )
pRegularPartitions( p, n )

</pre>

<p>Here <var class="Arg">p</var> is the characteristic and <var class="Arg">n</var> the degree.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRestrictedPartitions(2,5);</span>
[ [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRegularPartitions(2,5);</span>
[ [ 3, 2 ], [ 4, 1 ], [ 5 ] ]
</pre></div>

<p>Finally, we have functions that test a given partition to check whether or not it is restricted or regular with respect to a given prime.</p>


<pre class="normal">

pRestricted( p, ptn )
pRegular( p, ptn )

</pre>

<p>The functions return true if the given partition <var class="Arg">ptn</var> is <span class="Math">p</span>-restricted or <span class="Math">p</span>-regular, respectively, and return false otherwise. The characteristic is <var class="Arg">p</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRestricted(2,[2,2,1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRestricted(2,[3,1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRegular(2,[3,2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRegular(2,[2,2,1]);</span>
false
</pre></div>

<p><a id="X802799E57A84025C" name="X802799E57A84025C"></a></p>

<h4>4.4 <span class="Heading">Schur algebras</span></h4>

<p>There are only a few functions for working directly with Schur algebra Weyl modules.</p>


<pre class="normal">

SchurAlgebraWeylModule( p, lambda )

</pre>

<p>This returns a Weyl module of highest weight <var class="Arg">lambda</var> in characteristic <var class="Arg">p</var>, regarded as a module for <span class="Math">GL_n</span> where <span class="Math">n</span> is the length of the given partition <var class="Arg">lambda</var>. Note that zero parts are allowed in <var class="Arg">lambda</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);</span>
&lt;Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3&gt;
</pre></div>

<p>There is also a category of Schur algebra Weyl modules.</p>


<pre class="normal">

IsSchurAlgebraWeylModule( V )

</pre>

<p>This returns true if the given <var class="Arg">V</var> belongs to the category, and returns false otherwise.</p>

<p>It is possible to compute the decomposition numbers of a Schur algebra Weyl module, and the result is returned using partition notation.</p>


<pre class="normal">

DecompositionNumbers( V )

</pre>

<p>This returns a list consiting of each highest weight of a composition factor (in partition notation) followed by its corresponding composition factor multiplicity.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= SchurAlgebraWeylModule(3, [2,2,1,1,0]);</span>
&lt;Schur algebra Weyl module of highest weight [ 2, 2, 1, 1, 0 ] at prime p = 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionNumbers(V);</span>
[ [ 2, 2, 1, 1, 0 ], 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V:= SchurAlgebraWeylModule(2, [4,2,1,1,0]);</span>
&lt;Schur algebra Weyl module of highest weight [ 4, 2, 1, 1, 0 ] at prime p = 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecompositionNumbers(V);</span>
[ [ 4, 2, 1, 1, 0 ], 1, [ 3, 3, 1, 1, 0 ], 1, [ 3, 2, 2, 1, 0 ], 1,
[ 4, 1, 1, 1, 1 ], 1, [ 2, 2, 2, 2, 0 ], 1, [ 2, 2, 2, 1, 1 ], 1 ]
</pre></div>

<p>Finally, we can compute the entire decomposition matrix for a given Schur algebra.</p>


<pre class="normal">

SchurAlgebraDecompositionMatrix( p, n, r )

</pre>

<p>Here, <var class="Arg">p</var> is the characteristic and <span class="Math">S(n,r)</span> is the Schur algebra in question, whose modules are the homogeneous polynomial modules for <span class="Math">GL_n</span> in degree <var class="Arg">r</var>. The rows and columns of the matrix are indexed by the partitions produced by <code class="keyw">BoundedPartitions(n,r)</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SchurAlgebraDecompositionMatrix(2, 4, 5);</span>
[ [ 1, 0, 1, 1, 0, 0 ], [ 0, 1, 0, 0, 0, 1 ], [ 0, 0, 1, 1, 1, 0 ],
[ 0, 0, 0, 1, 1, 0 ], [ 0, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundedPartitions(4,5);</span>
[ [ 5, 0, 0, 0 ], [ 4, 1, 0, 0 ], [ 3, 2, 0, 0 ], [ 3, 1, 1, 0 ],
[ 2, 2, 1, 0 ], [ 2, 1, 1, 1 ] ]
</pre></div>

<p><a id="X7BE4F15F78127B12" name="X7BE4F15F78127B12"></a></p>

<h4>4.5 <span class="Heading">Symmetric groups</span></h4>

<p>Symmetric group decomposition numbers in positive characteristic may be obtained from corresponding decomposition numbers for a Schur algebra Weyl module, by means of the well known Schur functor. (See for instance Chapter 6 of <a href="chapBib.html#biBGreen">[Gre07]</a> for details.) This method is quite slow. People needing such numbers for large partitions should use other methods.</p>


<pre class="normal">

SymmetricGroupDecompositionNumbers( p, mu )

</pre>

<p>This returns a list of the decomposition numbers <span class="Math">[S_\mu : D_\lambda]</span> for the dual Specht module <span class="Math">S_\mu</span> labeled by a partition <var class="Arg">mu</var>, in characteristic <var class="Arg">p</var>. The simple modules <span class="Math">D_\lambda</span> are labeled by <span class="Math">p</span>-restricted partitions of the same degree as <span class="Math">\mu</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SymmetricGroupDecompositionNumbers(3, [3,2,1]);</span>
[ [ 3, 2, 1 ], 1, [ 2, 2, 2 ], 1, [ 3, 1, 1, 1 ], 1, [ 2, 1, 1, 1, 1 ], 1,
[ 1, 1, 1, 1, 1, 1 ], 1 ]
</pre></div>

<p>One can also compute the decomposition matrix for a symmetric group in positive characteristic.</p>


<pre class="normal">

SymmetricGroupDecompositionMatrix( p, n )

</pre>

<p>This returns the decomposition matrix for the symmetric group on <var class="Arg">n</var> letters, in characteristic <var class="Arg">p</var>. The rows of the matrix are labeled by the partitions of <var class="Arg">n</var> (in the order produced by <code class="keyw">AllPartitions</code>) and the columns are labeled by <span class="Math">p</span>-restricted partitions of <var class="Arg">n</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SymmetricGroupDecompositionMatrix(2, 5);</span>
[ [ 0, 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 1 ], [ 1, 0, 2 ], [ 1, 0, 1 ],
[ 0, 1, 0 ], [ 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllPartitions(5);</span>
[ [ 5 ], [ 4, 1 ], [ 3, 2 ], [ 3, 1, 1 ], [ 2, 2, 1 ], [ 2, 1, 1, 1 ],
[ 1, 1, 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pRestrictedPartitions(2,5);</span>
[ [ 2, 2, 1 ], [ 2, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
</pre></div>

<p>Note that <strong class="pkg">GAP</strong> has a built-in <code class="keyw">Partitions</code> function that also gives all the partitions of <span class="Math">n</span>, but the ordering is different from the ordering in <code class="keyw">AllPartitions</code>. To correctly interpret row labels in the decomposition matrix, one must use the ordering given in <code class="keyw">AllPartitions</code>.</p>

<p><a id="X78EDAF2F86560B70" name="X78EDAF2F86560B70"></a></p>

<h4>4.6 <span class="Heading">The Mullineux correspondence</span></h4>

<p>Computing symmetric group decomposition numbers by means of the Schur functor naturally produces the numbers <span class="Math">[S_\mu : D_\lambda]</span> for partitions <span class="Math">\mu</span> and <span class="Math">p</span>-restricted partitions <span class="Math">\lambda</span>. Here <span class="Math">S_\mu</span> is the dual Specht module labeled by <span class="Math">\mu</span> and <span class="Math">D_\lambda</span> is the dual simple module labeled by <span class="Math">\lambda</span>.</p>

<p>Let <span class="Math">\lambda'</span> be the conjugate partition of a partition <span class="Math">\lambda</span>, obtained by transposing rows and columns of the corresponding Young diagram. We have <span class="Math">(S^\mu)^* \cong S_\mu</span> for a partition <span class="Math">\mu</span> and <span class="Math">D^\lambda ⊗ sgn \cong D_{\lambda'}</span> for a <span class="Math">p</span>-regular partition <span class="Math">\lambda</span>, where <span class="Math">S^\mu</span> is the usual Specht module and <span class="Math">D^\lambda</span> is the usual simple module, using notation in accord with <a href="chapBib.html#biBJames">[Jam78]</a>. The notation <span class="Math">sgn</span> here refers to the sign representation.</p>

<p>Thus it follows that <span class="Math">[S_\mu : D_\lambda] = [S^\mu : D^{Mull(λ)}]</span> if <span class="Math">\lambda</span> is <span class="Math">p</span>-restricted. So by sending <span class="Math">\lambda \to Mull(\lambda')</span>, one obtains the column labels for the decomposition matrix that appear in <a href="chapBib.html#biBJames">[Jam78]</a>.</p>


<pre class="normal">

Mullineux( p, mu )

</pre>

<p>This returns the partition <span class="Math">Mull(µ)</span> corresponding to a given <span class="Math">p</span>-regular partition <span class="Math">\mu</span> under the Mullineux map.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mullineux(3, [5,4,1,1]);</span>
[ 9, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mullineux(3, [9,2]);</span>
[ 5, 4, 1, 1 ]
</pre></div>

<p><code class="keyw">pRegularPartitions(p,n)</code> returns a list of the <span class="Math">p</span>-regular partitions of <span class="Math">n</span>, in bijection with the list of <span class="Math">p</span>-restricted partitions of <span class="Math">n</span> produced by <code class="keyw">pRestrictedPartitions(p,n)</code>, using the bijection <span class="Math">\lambda \to Mull(\lambda')</span>. Thus, to read a symmetric group decomposition matrix using <span class="Math">p</span>-regular partition notation, one uses the output of <code class="keyw">pRegularPartitions</code> to index the columns of the matrix.</p>

<p>Finally, we have a function that computes the conjugate of a partition.</p>


<pre class="normal">

Conjugate( lambda )

</pre>

<p>This returns the conjugate (or transpose) of the input partition.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Conjugate( [4,4,2,1] );</span>
[ 4, 3, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Conjugate( [4,3,2,2] );</span>
[ 4, 4, 2, 1 ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
